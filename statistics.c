/*-
 * Copyright (c) 2018, 2020 Robert Clausecker. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* statistics.c -- functions to deal with stat files */

#include <errno.h>
#include <stdio.h>
#include <string.h>

#include "statistics.h"

/*
 * bias values for the equilibrium distribution.  The sum
 * of this array should equal 25.
 */
const double equilibrium_bias[TILE_COUNT] = {
        0.624881270497094521,
        0.871700741639200527,
        0.959307577450483784,
        0.871700741639200527,
        0.624881270497094521,

        0.871700741639200527,
        1.216010494873466685,
        1.338220820826442115,
        1.216010494873466685,
        0.871700741639200527,

        0.959307577450483784,
        1.338220820826442115,
        1.472713412296449809,
        1.338220820826442115,
        0.959307577450483784,

        0.871700741639200527,
        1.216010494873466685,
        1.338220820826442115,
        1.216010494873466685,
        0.871700741639200527,

        0.624881270497094521,
        0.871700741639200527,
        0.959307577450483784,
        0.871700741639200527,
        0.624881270497094521,
};

/*
 * Sphere sizes.  Exact sizes til distance 30, measured sizes for
 * distances 31 to 55.  See doc/spheresample.csv.
 */
const double sphere_sizes[MAX_SPHERE + 1] = {
	1.0,
	2.0,
	4.0,
	10.0,
	26.0,
	64.0,
	159.0,
	366.0,
	862.0,
	1904.0,
	4538.0,
	10238.0,
	24098.0,
	53186.0,
	123435.0,
	268416.0,
	616374.0,
	1326882.0,
	3021126.0,
	6438828.0,
	14524718.0,
	30633586.0,
	68513713.0,
	143106496.0,
	317305688.0,
	656178756.0,
	1442068376.0,
	2951523620.0,
	6427133737.0,
	13014920506.0,
	28070588413.0,		/* last exact */
	56194425546.75915,	/* first measured */
	119942432304.2539,
	237828799036.6756,
	502022270776.212,
	981344197696.946,
	2053344712683.699,
	3961888589186.432,
	8191376710847.424,
	15587509077640.82,
	31793778641251.32,
	59655294384121.67,
	120427504752321.8,
	222660301060780.3,
	441870908608010.5,
	805129181181757.2,
	1579200413062696.0,
	2837362412832600.0,
	5474452709508327.0,
	9631063122265580.0,
	1.83966541588426e+16,
	3.187398532093945e+16,
	5.930682118910411e+16,
	1.011772086267403e+17,
	1.869119262098732e+17,
	3.107760932006477e+17,
	5.639574623017318e+17,
	9.278936973398657e+17,
	1.649715470825660e+18,
	2.635829031743155e+18,
	4.588785499796897e+18,
	7.157151958026815e+18,
	1.241002349560186e+19,
	1.902028179043278e+19,
	3.048386825388594e+19,
};


/*
 * Parse a stat file generated by samplegen.  These files first contain
 * total number of samples and then lines of the form
 *
 *     AA: BBBB/ CCCC = D.DDDe-DD
 *
 * where A is a distance, B is the number of samples found for this
 * distance, C is the total number of samples and D.DDDe-DD is B/C in
 * scientific notation.  This function parses a stat file and stores the
 * B and C values to hits and samples.  The return value is the number
 * of the highest round appearing in the stat file.  All entries not
 * appearing in the file are set to 0.  If the file is invalid or does
 * not contain any entries, return -1.
 */
extern int
parse_stat_file(struct stat_file *stats, FILE *statfile)
{
        double hits_i, samples_i;
        int i, items;

        memset(stats->hits, 0, PDB_HISTOGRAM_LEN * sizeof *stats->hits);
        memset(stats->samples, 0, PDB_HISTOGRAM_LEN * sizeof *stats->samples);
	stats->max_i = -1;

        items = fscanf(statfile, "%lf\n\n", &stats->total);
        if (items != 1) {
		errno = EINVAL;
                return (-1);
	}

        while (items = fscanf(statfile, "%d: %lf/%lf = %*le\n", &i, &hits_i, &samples_i),
            items == 3) {
                if (i < 0) {
			errno = EINVAL;
                        return (-1);
		}

                if (i > stats->max_i)
                        stats->max_i = i;

                /* be robust against duplicate lines, take the sum in such cases */
                stats->hits[i] += hits_i;
                stats->samples[i] += samples_i;
        }

        /* account for strata without hits */
        for (i = 0; i <= stats->max_i ; i++)
                if (stats->samples[i] == 0)
                        stats->samples[i] = stats->total;

	if (items != EOF) {
		errno = EINVAL;
		return (-1);
	}

	/* errno has already been set by the previous IO operation */
        if (ferror(statfile))
                return (-1);

        return (stats->max_i);
}

/*
 * Write a statistics file.  The reported total is zero if there is no
 * common total.  Differently from samplgen, we do print lines with zero
 * hits to compensate for the possible lack of a common total.  Ignore
 * errors.
 */
extern void
write_stat_file(FILE *statfile, const struct stat_file *stat)
{
        double total = 0;
        size_t i, i_max = 0;

        /* find the largest group with nonzero total */
        for (i = 0; i < PDB_HISTOGRAM_LEN; i++)
                if (stat->samples[i] != 0)
                        i_max = i;

        /* next, try to find a common total */
        total = stat->samples[0];
        for (i = 1; i <= i_max; i++)
                if (stat->samples[i] != total)
                        total = 0;

        fprintf(statfile, "%.0f\n\n", total);

        for (i = 0; i <= i_max ; i++)
                fprintf(statfile, "%3zu: %18.0f/%24.0f = %24.18e\n",
                    i, stat->hits[i], stat->samples[i],
		    stat->hits[i] / (double)stat->samples[i]);
}
