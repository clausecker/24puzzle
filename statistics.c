/*-
 * Copyright (c) 2018 Robert Clausecker. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* statistics.c -- functions to deal with stat files */

#include <stdio.h>
#include <string.h>

#include "statistics.h"

/*
 * Parse a stat file generated by samplegen.  These files first contain
 * total number of samples and then lines of the form
 *
 *     AA: BBBB/ CCCC = D.DDDe-DD
 *
 * where A is a distance, B is the number of samples found for this
 * distance, C is the total number of samples and D.DDDe-DD is B/C in
 * scientific notation.  This function parses a stat file and stores the
 * B and C values to hits and samples.  The return value is the number
 * of the highest round appearing in the stat file.  All entries not
 * appearing in the file are set to 0.  If the file is invalid or does
 * not contain any entries, return -1.
 */
extern int
parse_stat_file(struct stat_file *stats, FILE *statfile)
{
        double hits_i, samples_i;
        int i, items;

        memset(stats->hits, 0, PDB_HISTOGRAM_LEN * sizeof *stats->hits);
        memset(stats->samples, 0, PDB_HISTOGRAM_LEN * sizeof *stats->samples);
	stats->max_i = -1;

        items = fscanf(statfile, "%lf\n\n", &stats->total);
        if (items != 1)
                return (-1);

        while (items = fscanf(statfile, "%d: %lf/%lf = %*le\n", &i, &hits_i, &samples_i),
            items == 3) {
                if (i < 0)
                        return (-1);

                if (i > stats->max_i)
                        stats->max_i = i;

                /* be robust against duplicate lines, take the sum in such cases */
                stats->hits[i] += hits_i;
                stats->samples[i] += samples_i;
        }

        /* account for strata without hits */
        for (i = 0; i <= stats->max_i ; i++)
                if (stats->samples[i] == 0)
                        stats->samples[i] = stats->total;

        if (items != EOF || ferror(statfile))
                return (-1);

        return (stats->max_i);
}

/*
 * Write a statistics file.  The reported total is zero if there is no
 * common total.  Differently from samplgen, we do print lines with zero
 * hits to compensate for the possible lack of a common total.  Ignore
 * errors.
 */
extern void
write_stat_file(FILE *statfile, const struct stat_file *stat)
{
        double total = 0;
        size_t i, i_max = 0;

        /* find the largest group with nonzero total */
        for (i = 0; i < PDB_HISTOGRAM_LEN; i++)
                if (stat->samples[i] != 0)
                        i_max = i;

        /* next, try to find a common total */
        total = stat->samples[0];
        for (i = 1; i <= i_max; i++)
                if (stat->samples[i] != total)
                        total = 0;

        fprintf(statfile, "%.0f\n\n", total);

        for (i = 0; i <= i_max ; i++)
                fprintf(statfile, "%3zu: %18.0f/%24.0f = %24.18e\n",
                    i, stat->hits[i], stat->samples[i],
		    stat->hits[i] / (double)stat->samples[i]);
}

