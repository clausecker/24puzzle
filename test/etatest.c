/*-
 * Copyright (c) 2018 Robert Clausecker. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* etatest.c -- compute eta using fixed samples */

/*
 * This program computes the heuristic quality factor eta by sampling
 * puzzle configurations.  The samples are stratified by the true
 * distance of the sample to the goal configuration.  Samples for the
 * first few equidistance classes as generated by puzzledist are taken
 * from a set of sample files, the remaining equidistance classes are
 * covered by random sample over the entire search space.
 */

#define _POSIX_C_SOURCE 200809L
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "parallel.h"
#include "puzzle.h"
#include "compact.h"
#include "catalogue.h"
#include "statistics.h"

/*
 * eqdist_sizes[d] is the fraction of 24 puzzle configurations which take
 * exactly d moves to solve.  This table contains exact values and is
 * used for the size of the first few strata.  For the remaining strata,
 * the size reported by the stat file is used instead.
 */
static const double eqdist_sizes[] = {
	1.289390056876894947e-25,
	2.578780113753789895e-25,
	5.157560227507579790e-25,
	1.289390056876894856e-24,
	3.352414147879926772e-24,
	8.252096364012127664e-24,
	2.050130190434262916e-23,
	4.719167608169434893e-23,
	1.111454229027883302e-22,
	2.454998668293607958e-22,
	5.851252078107348595e-22,
	1.320077540230564949e-21,
	3.107172159061941253e-21,
	6.857749956505453533e-21,
	1.591558616705995256e-20,
	3.460929215066686377e-20,
	7.947465069174391349e-20,
	1.710868457448927948e-19,
	3.895409824972265617e-19,
	8.302160801140543152e-19,
	1.872802696814086005e-18,
	3.949864119488325207e-18,
	8.834090030191725332e-18,
	1.845200930168931178e-17,
	4.091307990976822429e-17,
	8.460703635202500731e-17,
	1.859388625351011329e-16,
	3.805665208265298760e-16,
	8.287082334705840204e-16,
	1.678130909147960556e-15,
	3.619393759040597566e-15,
};

/* size of the eqdist_sizes array */
enum { EQDIST_SIZES_LEN = sizeof eqdist_sizes / sizeof eqdist_sizes[0] };


/*
 * Accumulate samples from sample file f into histogramm.  On IO error,
 * terminate the program.  Return the number of samples read from f.
 */
static size_t
do_samples(size_t histogram[PDB_HISTOGRAM_LEN], FILE *samplefile, const char *filename,
    struct pdb_catalogue *cat)
{
	struct puzzle p;
	struct compact_puzzle cp;
	size_t n_samples = 0;

	while (fread(&cp, sizeof cp, 1, samplefile) == 1) {
		n_samples++;
		unpack_puzzle(&p, &cp);
		histogram[catalogue_hval(cat, &p)]++;
	}

	/* ignore errors but do report them */
	if (ferror(samplefile))
		perror(filename);

	return (n_samples);
}

/*
 * From a histogram for distance class d with n_samples samples, compute
 * the corresponding partial eta value and return it.  If f is not NULL,
 * print details about the samples to f.  Weight the samples by weight.
 * If use is nonzero, prefix line with an asterisk.  If brief is nonzero,
 * omit detailed histogram listing.
 */
static double
partial_eta(size_t histogram[PDB_HISTOGRAM_LEN], size_t n_samples, int use,
    int brief, int d, double weight, FILE *f)
{
	double eta = 0, invb = 1.0 / B;
	size_t i, end;

	for (i = 1; i <= PDB_HISTOGRAM_LEN; i++)
		eta = eta * invb + (double)histogram[PDB_HISTOGRAM_LEN - i];

	eta = (eta / (double)n_samples) * weight;

	if (f != NULL) {
		fprintf(f, "%c%3d: %13zu %e", use ? ' ' : '*', d, n_samples, eta);

		if (!brief) {
			end = 0;
			for (i = 0; i < PDB_HISTOGRAM_LEN; i++)
				if (histogram[i] != 0)
					end = i + 1;

			for (i = 0; i < end; i++)
				fprintf(f, " %g", (double)histogram[i] / (double)n_samples);
		}

		putc('\n', f);
	}

	return (eta);
}

/*
 * Accumulate partial eta values from fixed sample files whose name
 * begins with prefix.  Return the value of eta computed this way.
 * Print extra information to f if f is not NULL.  If no sample file
 * whose name begins with prefix could be opened, print an error
 * message and terminate.  Sample files with less than threshold
 * samples are evaluated but disregarded for the sum.
 */
static double
compute_eta(struct pdb_catalogue *cat, const char *prefix, size_t threshold,
    int brief, FILE *f)
{
	struct stat_file stats;
	FILE *statfile, *samplefile;
	double eta = 0.0, eta_d, weight;
	size_t histogram[PDB_HISTOGRAM_LEN], n_samples, d;
	int use;
	char pathbuf[PATH_MAX];

	/* load and parse statistics file */
	snprintf(pathbuf, PATH_MAX, "%s.stat", prefix);
	statfile = fopen(pathbuf, "r");
	if (statfile == NULL) {
		perror(pathbuf);
		exit(EXIT_FAILURE);
	}

	if (parse_stat_file(&stats, statfile) == -1) {
		perror(pathbuf);
		exit(EXIT_FAILURE);
	}

	fclose(statfile);

	for (d = 0; d <= stats.max_i; d++) {
		if (d < EQDIST_SIZES_LEN)
			weight = eqdist_sizes[d];
		else if (stats.hits[d] > 0)
			weight = stats.hits[d] / stats.samples[d];
		else /* no data */
			continue;

		snprintf(pathbuf, PATH_MAX, "%s.%zu", prefix, d);
		samplefile = fopen(pathbuf, "rb");
		if (samplefile == NULL) {
			perror(pathbuf);
			continue;
		}

		memset(histogram, 0, sizeof histogram);
		n_samples = do_samples(histogram, samplefile, pathbuf, cat);
		fclose(samplefile);

		use = n_samples >= threshold || d < EQDIST_SIZES_LEN;
		eta_d = partial_eta(histogram, n_samples, use, brief, d, weight, f);
		if (use)
			eta += eta_d;
	}

	return (eta);
}

static void
usage(const char *argv0)
{
	printf("Usage: %s [-Biq] [-d pdbdir] -f prefix [-h threshold] [-j nproc] catalogue\n", argv0);
	exit(EXIT_FAILURE);
}

extern int
main(int argc, char *argv[])
{
	struct pdb_catalogue *cat;
	FILE *details = stdout, *messages = stderr;
	double eta;
	size_t threshold = 0;
	int brief = 0, optchar, catflags = 0;
	char *pdbdir = NULL, *prefix = NULL;

	while (optchar = getopt(argc, argv, "Bd:f:h:ij:q"), optchar != -1)
		switch (optchar) {
		case 'B':
			brief = 1;
			break;

		case 'd':
			pdbdir = optarg;
			break;

		case 'f':
			prefix = optarg;
			break;

		case 'h':
			threshold = atol(optarg);
			break;

		case 'j':
			pdb_jobs = atoi(optarg);
			if (pdb_jobs < 1 || pdb_jobs > PDB_MAX_JOBS) {
				fprintf(stderr, "Number of threads must be between 1 and %d\n",
				    PDB_MAX_JOBS);
				return (EXIT_FAILURE);
			}

			break;

		case 'i':
			catflags |= CAT_IDENTIFY;
			break;

		case 'q':
			details = NULL;
			messages = NULL;
			break;

		default:
			usage(argv[0]);
		}

	if (prefix == NULL) {
		printf("Missing mandatory option -f prefix.\n");
		usage(argv[0]);
	}

	if (argc != optind + 1)
		usage(argv[0]);

	cat = catalogue_load(argv[optind], pdbdir, catflags, messages);
	if (cat == NULL) {
		perror("catalogue_load");
		return (EXIT_FAILURE);
	}

	eta = compute_eta(cat, prefix, threshold, brief, details);
	printf("eta = %e\n", eta);

	return (EXIT_SUCCESS);
}
