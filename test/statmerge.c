/*-
 * Copyright (c) 2018 Robert Clausecker. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* samplemerge.c -- merge sets of samples generated by samplegen */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <string.h>

#include "pdb.h"

/*
 * Parse a stat file generated by samplegen.  These files first contain
 * total number of samples and then lines of the form
 *
 *     AA: BBBB/ CCCC = D.DDDe-DD
 *
 * where A is a distance, B is the number of samples found for this
 * distance, C is the total number of samples and D.DDDe-DD is B/C in
 * scientific notation.  This function parses a stat file and stores the
 * B and C values to hits and samples.  The return value is the number
 * of the highest round appearing in the stat file.  All entries not
 * appearing in the file are set to 0.  If the file is invalid or does
 * not contain any entries, return -1.
 */
static int
parse_stat_file(size_t hits[restrict PDB_HISTOGRAM_LEN], size_t samples[restrict PDB_HISTOGRAM_LEN],
    FILE *statfile)
{
	size_t hits_i, samples_i, total;
	int i, max_i = -1, items;

	memset(hits, 0, PDB_HISTOGRAM_LEN * sizeof *hits);
	memset(samples, 0, PDB_HISTOGRAM_LEN * sizeof *samples);

	items = fscanf(statfile, "%zu\n\n", &total);
	if (items != 1)
		return (-1);

	while (items = fscanf(statfile, "%d: %zu/%zu = %*le\n", &i, &hits_i, &samples_i),
	    items == 3) {
		if (i < 0)
			return (-1);

		if (i > max_i)
			max_i = i;

		/* be robust against duplicate lines, take the sum in such cases */
		hits[i] += hits_i;
		samples[i] += samples_i;
	}

	/* account for strata without hits */
	for (i = 0; i <= max_i ; i++)
		if (samples[i] == 0)
			samples[i] = total;

	if (items != EOF || ferror(statfile))
		return (-1);

	return (max_i);
}

/*
 * Add new_hits and new_samples to hits and samples.
 */
static void
merge_stats(size_t hits[restrict PDB_HISTOGRAM_LEN], size_t samples[restrict PDB_HISTOGRAM_LEN],
    const size_t new_hits[restrict PDB_HISTOGRAM_LEN], const size_t new_samples[restrict PDB_HISTOGRAM_LEN])
{
	size_t i;

	for (i = 0; i < PDB_HISTOGRAM_LEN; i++) {
		hits[i] += new_hits[i];
		samples[i] += new_samples[i];
	}
}

/*
 * Write statistics about the merged samples.  The reported total is
 * zero if there is no common total.  Differently from samplgen, we
 * do print lines with zero hits to compensate for the possible lack of
 * a common total.  Ignore errors.
 */
static void
write_stats(FILE *statfile, const size_t hits[restrict PDB_HISTOGRAM_LEN],
    const size_t samples[restrict PDB_HISTOGRAM_LEN])
{
	size_t i, i_max = 0, total = 0;

	/* find the largest group with nonzero total */
	for (i = 0; i < PDB_HISTOGRAM_LEN; i++)
		if (samples[i] != 0)
			i_max = i;

	/* next, try to find a common total */
	total = samples[0];
	for (i = 1; i <= i_max; i++)
		if (samples[i] != total)
			total = 0;

	fprintf(statfile, "%zu\n\n", total);

	for (i = 0; i <= i_max ; i++)
		fprintf(statfile, "%3zu: %20zu/%20zu = %24.18e\n",
		    i, hits[i], samples[i], hits[i] / (double)samples[i]);
}

extern int
main(int argc, char *argv[])
{
	FILE *statfile;
	size_t i;
	size_t total_hits[PDB_HISTOGRAM_LEN], total_samples[PDB_HISTOGRAM_LEN];
	size_t hits[PDB_HISTOGRAM_LEN], samples[PDB_HISTOGRAM_LEN];
	int res;

	memset(total_hits, 0, sizeof total_hits);
	memset(total_samples, 0, sizeof total_samples);

	for (i = 1; i < argc; i++) {
		statfile = fopen(argv[i], "r");
		if (statfile == NULL) {
			perror(argv[i]);
			return (EXIT_FAILURE);
		}

		res = parse_stat_file(hits, samples, statfile);
		if (res < 0) {
			if (ferror(statfile))
				perror(argv[i]);
			else
				fprintf(stderr, "Cannot parse statistics file %s\n", argv[i]);
			return (EXIT_FAILURE);
		}

		merge_stats(total_hits, total_samples, hits, samples);
		fclose(statfile);
	}

	write_stats(stdout, total_hits, total_samples);

	return (EXIT_SUCCESS);
}
